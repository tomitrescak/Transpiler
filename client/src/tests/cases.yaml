# TEST Case
- name: TypeDeclaration
  input: interface tomi {}
  output: |
    interface tomi {}

# TEST Case
- input: class tomi {}
  output: |
    class tomi {}

# TEST Case
- name: Enums
  input: |
    enum Animals {
      Cat,
      Dog
    }
  output: |
    enum Animals {
      Cat,
      Dog
    }

# # TEST Case
# - name: Enums > Errors
#   input: |
#     public enum Level {
#       HIGH  (3),  //calls constructor with value 3
#       MEDIUM(2),  //calls constructor with value 2
#       LOW   (1)   //calls constructor with value 1
#       ; // semicolon needed when fields / methods follow
#
#       private final int levelCode;
#
#       private Level(int levelCode) {
#           this.levelCode = levelCode;
#       }
#     }
#   errors:
#     - SimpleEnumsOnlySupported

# TEST Case
- name: Types
  input: |
    class tomi {
      byte aa;
      short bb;
      int cc;
      long dd;
      float ee;
      double ff;
      char gg;
      String hh, ii;
    }
  output: |
    class tomi {
      aa: number = 0;
      bb: number = 0;
      cc: number = 0;
      dd: number = 0;
      ee: number = 0;
      ff: number = 0;
      gg: string = null;
      hh: string = null, ii: string = null;
    }
  sourceMap: [0,1,2,3,4,5,6,7,8]

# TEST Case
- name: ArrayTypes
  input: |
    class tomi {
      int[] a;
      int[][] aa;
      String b[];
      String bb[][];
      T[] d[];
    }
  output: |
    class tomi {
      a: number[] = null;
      aa: number[][] = null;
      b: string[] = null;
      bb: string[][] = null;
      d: T[][] = null;
    }
  #sourceMap: [0,1,2,3,4,5,5,5]

# TEST Case
- name: Initialisers
  input: |
    class tomi {
      int a = 4;
    }
  output: |
    class tomi {
      a: number = 4;
    }

# TEST Case
- name: Modifiers
  input: public static final abstract class tomi {}
  output: |
    abstract class tomi {}
  warnings:
    - IgnoredModifier|1|public
    - IgnoredModifier|1|final
  errors:
    - UnexpectedModifier|1|static

# TEST Case
- name: Modifiers
  input: public private protected class tomi {}
  output: |
    class tomi {}
  errors:
    - DuplicateAccessor|1|public,private,protected

# TEST Cases
- name: TypeParameter
  input: class tomi<T,U> {}
  output: |
    class tomi<T,U> {}

- name: TypeParameter > TypeBounds
  input: class tomi<T extends U & V> {}
  output: |
    class tomi<T extends U & V> {}

# TEST Case Annotation
- name: Annotations
  input: |
    @annotation1
    class tomi {}
  output: |
    class tomi {}
  warnings:
    - IgnoredAnnotation|1
  sourceMap: [1] # line[0] = 0, line[1] = 0

# Test Case - Class Variables

- name: TypeParameter > TypeBounds
  input: class tomi<T extends U & V> {}
  output: |
    class tomi<T extends U & V> {}

# Test Case - Class Variables

- name: SourceMap > Simple
  input: class tomi { int a; int b; }
  output: |
    class tomi {
      a: number = 0;
      b: number = 0;
    }
  sourceMap: [0,0,0]

# Test Cases - Expressions

- name: Expressions > Simple Binary
  input: |
    class tomi {
      int a = 4 + 5;
    }
  output: |
    class tomi {
      a: number = 4 + 5;
    }
  sourceMap: [0,1]

- name: Expressions > Logical and unary
  input: |
    class tomi {
      boolean a = true && false || !a;
    }
  output: |
    class tomi {
      a: boolean = true && false || !a;
    }
  sourceMap: [0,1]

- name: Expressions > Parenthesis
  input: |
    class tomi {
      int a = ((4 + 5) * 2) / (4 * 5);
    }
  output: |
    class tomi {
      a: number = ((4 + 5) * 2) / (4 * 5);
    }
